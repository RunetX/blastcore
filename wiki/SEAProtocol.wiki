= Графическое представление протокола SEA Sender =

Все длины и идентификаторы - в сетевом порядке байт (сначала старший, потом младший).

http://blastcore.googlecode.com/files/incoming.png

http://blastcore.googlecode.com/files/outgoing.png

*Отличия команды #4 от показанного на схеме:*

После тела сообщения идёт еще один байт, обозначающий длину. Если он нулевой, как в подавлящем большинстве случаев, более никаких байт не идет. Если он ненулевой, то это длина следующего поля - имени пользователя, за которым идет байт длины имени компьютера, и затем собственно имя компьютера - то есть, структура такая же, как в команде #2, если из неё убрать байт #2 и ID. Эти имя пользователя и компьютера используются в том случае, если сообщение пришло из TCPSender, причем ID отправителя неизвестен (является нулевым). _Зачем это нужно и когда может случиться, никто не знает, надо спрашивать авторов оригинального Java-сервера._

Специальные значения и константы:

 * ID=0 используется как идентификатор группы всех пользователей
 * ID=65535 используется как идентификатор группы Печатников
 * Факультет с ASCII-значением '1' означает АВТФ
 * Реализация оригинального Java-сервера и штатного клиента использует номер 1000 как разделитель идентификаторов клиентов SEA Sender и TCPSender - в команде #2 не предусмотрено флага, в который из списков следует добавить пользователя, и они различаются этой константой (если идентификатор более 1000, то это пользователь TCPSender).

Замечания по схеме, вытекающие из реализации:

 * Оригинальный клиент (до версии 0.9.7.4 включительно), по-видимому, использует знаковое представление чисел - замечено на байтах длины в чате и в имени пользователя (приводит к явным ошибкам переполнения буфера и выпадению в дебаггер). По-видимому, то же применимо и к идентификаторам пользователей, хотя значение  65535 == -1 обрабатывается верно, на практике проверено не было.
    * Считаю, что это ошибка штатного клиента, и все эти числа следует трактовать как беззнаковые. -- nuclight
 * Поле isPrinter в команде #4 от сервера представляет собой два байта, каждый из которых установлен в единицу, если это сообщение для группы Печатников, и два нуля в противном случае.
    * Штатный клиент 0.9.7.4 рассматривает эти два байта как 16-битное число в сетевом порядке байт, то есть достаточно установить в единицу второй байт. Blastcore же версий до 0.4 завязался на отсылку штатным сервером обоих единичных байтов, и проверяет первый из них на строгое соответствие нулю или единице.

Реализация чата - документировать позднее.

== Версии протокола ==

Байт версии протокола изначально отражал версию штатного клиента в виде Major*10+Minor, без учета подверсий, то есть и для 0.9.7.3 и для 0.9.7.4 это значение было 97. В конце цикла разработки Бласта это значение стало 98, дабы отличаться от штатного клиента, и 13 сентября 2009 выставлено в 100 ("1.0.0"), символически отражая полноту поддержки протокола и готовность замены штатного клиента.

После этого байт версии протокола будет меняться только с целью соответствующей обработки сервером версии именно протокола, а не различения индивидуальных клиентов. Причем есть подозрение, что штатный клиент и этот байт обрабатывает как знаковый, то есть не следует делать номера более 127. Впрочем, из этого протокола всё равно много не выжмешь, скорее всего, до этого и не дойдет.

= Расширения протокола версий более 100, применяемые в Blastcore =

Расширения ставят целью поддержку форматированного текста (RTF) и передачи файлов, которую просили пользователи. Причем не все из них, вообще говоря, требуют изменения протокола, благодаря обнаруженным особенностям реализации, которые позволяют "хакнуть" протокол без потери совместимости.

Однако следует помнить, что штатный клиент не поддерживает сообщения длиннее 32 Кб.

== Структура сообщения и двоичный ноль ==

Было обнаружено, что как штатный клиент, так и Blastcore всех версий без специальной обработки (до введения расширений) игнорирует ту часть сообщения, что идет после встречающегося в сообщении двоичного нуля '\0' - в Си это конец строки (Blastcore грузит текст как есть в написанный на Си контрол). Это позволяет передавать после двоичного нуля (называемого также ASCIIZ) расширенную информацию, которая будет проигнорирована старыми версиями. Архивер был модифицирован, чтобы вести себя аналогично старой версии.

Таким образом, сообщение может быть представлено как любое количество частей, разделенных символом ASCIIZ, каждая из которых представляет кусок информации в своем формате, и формат определяется первыми байтами после '\0' (сигнатурой), в нижеследующем порядке:

  * Plain text как в старых версиях, обязательная часть, всегда первая (нет сигнатуры);
  * Сигнатура `{\rtf` - тот же текст, что и в первой части, но с форматированием;
  * Возможно, какая-нибудь другая, еще не придуманная часть со своей сигнатурой;
  * Сигнатура `FILE` - приложенный к сообщению файл. Всегда последняя, поскольку в двоичных данных файла может встретиться символ '\0', который уже не должен интерпретироваться как разделитель (кроме того, это позволяет не указывать длину файла - он будет до конца сообщения).

В общих чертах алгоритм обработки форматированного текста такой:

  * Отправитель (версии после 0.4) из составленного ричтекста генерирует plaintext-версию и приписывает её перед RTF-версией - это то, что увидят старые версии и архивер. _Помнить об ограничении 32Кб штатного._
  * Получатель (начиная с 0.4) видит сигнатуру `#0 {\rtf` и загружает для показа пользователю в RichEdit RTF-версию, вырезая её из строки - контрол не видит символов '\0'.
    * Версия 0.4 умеет распознавать, что после RTF идет еще один '\0' и что-то еще, но игнорирует его, ограничиваясь только вырезанием RTF.
  * Для цитирования в ответном сообщении получатель использует plaintext-версию - таким образом, алгоритмы цитирования не требуют переделки.

=== Формат приложенного файла ===

Придумать и документировать к версии 0.5.

== Изменения длины ==

Здесь используется тот факт, что клиент передает серверу трехбайтное поле длины, а значит, может быть передана команда длиной до 16 мегабайт. Это нигде не используется в штатном протоколе - там ограничения до 64 Кб, так как в формате сообщения от сервера к клиенту отведено всего два байта. Из двух байт, отведенных для флага Печатников, один можно использовать для дополнительного байта длины при передаче от сервера к клиенту, но оба используются как флаг - возможно, придется использовать две половинки байтов. Кроме того, надо учесть, что новый клиент посылает длинное сообщение на группу, в которой есть и старые - что он должен указать в поле длины сообщения (полная длина - в длине команды), чтобы сервер правильно его понял, и старым клиентам сгенерировал сообщение длиной не более 32 (для <= 97) или 64 (для <= 100) килобайт.

Придумать и документировать позднее.